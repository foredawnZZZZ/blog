## 导航流程

- 用户从浏览器输入请求信息
- 网络进程发起URL请求
- 服务器响应后，浏览器开始准备渲染进程
- 准备之后开始提交文档阶段
- 开始解析页面加载子资源

**用户发出 URL 请求到页面开始解析的这个过程，就叫做导航**。

##### <u>在浏览器里，从输入 URL 到页面展示，这中间发生了什么？</u>

- **用户输入**
  - 在地址栏输入关键字时，会判断时搜索内容还是，请求URL
  - 如果是内容地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。
  - 如果是符合URL规则，那么就会附加上协议合成完整的URL
  - 我们在地址栏输入后 回车时地址前面那个转圈圈其实就是等待提交文档阶段！

- **URL请求过程**
  - 主进程会利用IPC机制把URL请求发送给网络进程 网络进程接收到URL后才会发真正的请求
  - 先会去查找本地缓存是否有，有就直接返回资源给主进程 没有进入流程
  - 先去DNS域名解析 获取对应的IP地址（https先要建立TLS链接）
  - 利用IP地址通过三次握手建立TCP链接 浏览器构建请求行头体
  - 服务器接收后生成相应行头体 给到网络进程 开始解析（对解析后的结果）
    - 重定向：在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。（一般跳转的地址在头的location字段）；
    - 响应数据类型：根据Content-Type字段区分数据类型，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。如果 Content-Type 字段的值被浏览器判断为**下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束**。但如果是**HTML，那么浏览器则会继续进行导航流程**。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

- **准备渲染阶段**
  - 每开开启一个tab就会开启一个渲染进程
  - **如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程反之不会**
  - 只有同一站点的情况下多个页面才会同时运行在一个渲染进程中（根域名加上协议包含该根下的所以子域以及不同端口）

- **提交文档**
  - 文档指的是请求的数据
  - 主进程发起 渲染进程接收和网络进程建立传输
  - 传输完渲染进程会返回“**确认提交**”的消息给浏览器进程。
  - 浏览器进程在收到“确认提交”的消息后，会**更新浏览器界面状态**，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。所以说之前页面没有马上消失而是要加载一会

- **渲染阶段！**

  - 经过HTML解析器，构建DOM树（因为浏览器无法直接识别html，所以需要将转为理解的结构）
  - 也会进行一个转换操作并且**标准化**（2rem = 32px blue = rgb（0，0，255）） ，**计算树节点具体样式**（根据继承和层叠原则） 生成样式结构表
  - 创建布局树（遍历可见树节点  像head和displaynone属于不可以见）
  - 分层图层树 
    - **渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树！**（3D变换，Z轴排序等）
    - **浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面**。
    - **并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层**。但不管怎么样每个节点最终都会属于一个图层
    - 一般满足层叠上下文属性和剪裁（Z-index overflow）

  - .................先略