## 堆内存和栈内存

如果你想成为大前端打造高性能前端应用，那么就必须搞清楚JavaScript的内存机制；

#### JavaScript是什么类型的语言

像C语言在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为静态语言，而js就是在运行过程中需要去检查数据类型的语言称为动态语言。

但是C语言是可以把其他数据类型赋予一个声明好的变量，这种偷偷的转换称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持的称为强类型语言。

#### JavaScript的数据类型

- 弱类型，意味着你不用去告诉js引擎这个变量是什么数据类型，它自己会计算出来
- 动态，说明你可以使用同一个变量保存不同的数据类型
  - js数据类型一共有8种：Boolean，String，Undefined，Null，Number，BigInt，Symbol，Object
  - 使用typeof检测null类型会是Object，这是语言上的bug
  - Object比较特殊，是键值对形式的数据类型，值可以是任何形式
  - 除了Object是引用类型，其他的都是原始类型

#### 内存空间

在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是**代码空间（可执行代码）、栈空间**和**堆空间**。

原始类型的数据值都是存放在栈中的，引用类型的值是存放在堆中的

**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。

```javascript
function foo(){
    var a = " Fore "
    var b = a
    var c = {name:" Dawn "}
    var d = c
}
foo()
之前的执行过程跟往常一样，当执行到第三行时js引擎判断右边是一个引用类型，并不是直接把对象放到变量环境当中，而是将他分配到堆空间里面，分配之后该对象在变量环境里会有一个堆中的地址
其实对象类型时存放在堆空间里面的，在栈空间中只是保留了对象的引用地址，js访问数据的时候，是通过栈中的引用地址访问的
```

#### 为什么会有两个空间呢，都存放在栈不可以吗？

当然不可以，因为js引擎需要栈来维护执行上下文的状态，如果栈空间大了，所有数据都放在栈空间里，那么会影响到上下文切换的效率

进而影响到整个程序的执行效率。比如上面的foo函数执行结束了，js引擎需要离开当前的执行上下文，只需要将指针下移到上一个执行上下文就可以了，然后整个栈被回收。所以**通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过缺点是分配内存和回收内存都会占用一定的时间。

#### 再谈闭包

```javascript
function foo() {
    var myName = " Fore "
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName(" Dawn ")
bar.getName()
console.log(bar.getName())
这个代码在学习js执行机制时介绍到，foo函数执行上下文销毁时，由于foo函数产生了闭包，所以myName和test1没有被销毁
站在内存空间的角度解释下：
  - 当js引擎执行到foo函数时，会先编译创建一个执行上下文
  - 在编译过程中，遇到内部函数set和get还要对内部函数做一次快速的扫描，发现内部函数引用了foo函数中的变量，于是js引擎就判断他是一个闭包，在堆空间里面创建一个closure对象这是一个内部对象js无法访问，用来保存变量，在扫描get时，又发现有引用foo的变量，就在添加一次
  - 由于test2没有被引用所以test2依然保存到调用栈中
记住当执行到foo函数时，闭包就已经产生了，foo函数执行上下文结束后，返回的get和set方法都引用了closure对象的变量总的来说，闭包产生的核心有两步：第一预扫描内部函数，第二内部函数引用的外部变量保存到堆中
```

