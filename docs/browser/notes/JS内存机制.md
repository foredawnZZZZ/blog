## 堆内存和栈内存

如果你想成为大前端打造高性能前端应用，那么就必须搞清楚JavaScript的内存机制；

#### JavaScript是什么类型的语言

像C语言在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为静态语言，而js就是在运行过程中需要去检查数据类型的语言称为动态语言。

但是C语言是可以把其他数据类型赋予一个声明好的变量，这种偷偷的转换称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持的称为强类型语言。

#### JavaScript的数据类型

- 弱类型，意味着你不用去告诉js引擎这个变量是什么数据类型，它自己会计算出来
- 动态，说明你可以使用同一个变量保存不同的数据类型
  - js数据类型一共有8种：Boolean，String，Undefined，Null，Number，BigInt，Symbol，Object
  - 使用typeof检测null类型会是Object，这是语言上的bug
  - Object比较特殊，是键值对形式的数据类型，值可以是任何形式
  - 除了Object是引用类型，其他的都是原始类型

#### 内存空间

在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是**代码空间（可执行代码）、栈空间**（池：const常量存放在栈里）和**堆空间**。

原始类型的数据值都是存放在栈中的，引用类型的值是存放在堆中的

**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。

**一般内存的生命周期就是内存分配，内存使用，内存回收**
```javascript
var a = {x:10};//给这个引用分配内存空间到堆
console.log(a.x = 1000);//使用这个内存
a = null;//使用完毕之后，释放掉
```

```javascript
function foo(){
    var a = " Fore "
    var b = a
    var c = {name:" Dawn "}
    var d = c
}
foo()
之前的执行过程跟往常一样，当执行到第三行时js引擎判断右边是一个引用类型，并不是直接把对象放到变量环境当中，而是将他分配到堆空间里面，分配之后该对象在变量环境里会有一个堆中的地址
其实对象类型时存放在堆空间里面的，在栈空间中只是保留了对象的引用地址，js访问数据的时候，是通过栈中的引用地址访问的
```

#### 为什么会有两个空间呢，都存放在栈不可以吗？

当然不可以，因为js引擎需要栈来维护执行上下文的状态，如果栈空间大了，所有数据都放在栈空间里，那么会影响到上下文切换的效率

进而影响到整个程序的执行效率。比如上面的foo函数执行结束了，js引擎需要离开当前的执行上下文，只需要将指针下移到上一个执行上下文就可以了，然后整个栈被回收。所以**通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过缺点是分配内存和回收内存都会占用一定的时间。

#### 再谈闭包

```javascript
function foo() {
    var myName = " Fore "
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName(" Dawn ")
bar.getName()
console.log(bar.getName())
这个代码在学习js执行机制时介绍到，foo函数执行上下文销毁时，由于foo函数产生了闭包，所以myName和test1没有被销毁
站在内存空间的角度解释下：
  - 当js引擎执行到foo函数时，会先编译创建一个执行上下文
  - 在编译过程中，遇到内部函数set和get还要对内部函数做一次快速的扫描，发现内部函数引用了foo函数中的变量，于是js引擎就判断他是一个闭包，在堆空间里面创建一个closure对象这是一个内部对象js无法访问，用来保存变量，在扫描get时，又发现有引用foo的变量，就在添加一次
  - 由于test2没有被引用所以test2依然保存到调用栈中
记住当执行到foo函数时，闭包就已经产生了，foo函数执行上下文结束后，返回的get和set方法都引用了closure对象的变量总的来说，闭包产生的核心有两步：第一预扫描内部函数，第二内部函数引用的外部变量保存到堆中
```

## JS垃圾回收
当某些变量在使用之后,不在被需要.这种数据称为垃圾数据.如果垃圾数据一直保存到内存中就会占用体积,所以需要对垃圾数据进行回收,已释放有限的内存空间
#### 不同语言下的垃圾回收策略
垃圾回收分为手动回收和自动回收两个种策略;C和C++就是手动回收的,何时分配内存,何时销毁内存都是由代码控制的,如果这段数据已经不需要了,但是又没有主动销毁,那么这种情况就是内存泄露.
自动回收策略像java,JavaScript和python垃圾数据都是垃圾回收器去释放的,并不需要手动通过代码去释放
#### 调用栈中的数据回收方式
```javascript
function foo() {
  var a = 1;
  var b = { name:"fore" };
  function showName() {
    var c = " dawn ";
    var d = { name:"lin" };
  }
  showName();
}
foo();
分析一下foo函数执行上下文是如何销毁的:
执行showName时会创建showName的函数执行上下文,压入调用栈,在执行showName时还存在一个记录当前执行状态的指针即ESP,指向调用栈的showName函数执行上下文,表示正在执行showName函数.当执行完毕后,执行流程进入到foo函数,那么就需要销毁showName的执行上下文了,这时ESP就会下移到foo函数的执行上下文,这个下移操作就是销毁showName函数执行上下文的过程,当ESP不指向showName的时候其实也就代表了它已经是一个无效内存了,有新的执行上下文就会替换他的这块内存.foo函数再次调用另一个函数时,showName的就会被替换了当一个函数执行结束之后，JavaScript 引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文。
```

#### 堆中数据回收方式
根据上面举的例子,当foo函数执行结束之后,ESP就应该是指向全局执行上下文了,那样的话,showName和foo就都是无效状态了,但是存在堆中的对象引用依然占据着空间.要回收堆中的垃圾数据,就需要js中的垃圾回收器
在垃圾回收领域有一个术语叫**代际假说**,后续浏览器的回收策略都是建立在他的基础上的,他有两个特点:
- 大部分对象在内存中的存在的时间很短,就是对象经过分配内存很快就不可访问
- 其次是不死对象,活得久
**V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。**
新生区通常就支持1~8M的容量,而老生区支持的容量就很大,V8又分别使用两个不同的垃圾回收器,效率回收，副垃圾回收器主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。

**垃圾回收器的工作流程**
  - 首先无论是新生代还是老生代，并且分别使用两个不同的垃圾回收器，其实无论什么类型的垃圾回收器，他们都有一个执行流程
  - 第一步是标记空间中的活动对象和非活动对象：活动对象就是还在使用的对象，非活动对象是可以进行垃圾回收的对象
  - 第二步回收非活动对象占据的内存，就是在所有标记完成后，统一清理内存中所以被标记为可回收的对象
  - 第三步进行内存整理，一般来说，频繁回收对象后，内存中会存在大量不连续的空间，这些不连续的内存空间称为内存碎片。当内存中出现了大大量的碎片后，如果需要分配较大的连续内存，就可能出现内存不足的情况。所以最后一步需要整理这些内存碎片 其实一个步骤是可选的因为有的垃圾回收器是不会产生内存碎片，比如副垃圾回收器

**1.副垃圾回收器**
主要负责新生区的垃圾回收，虽然它的容量不大但是整个垃圾回收的频率还是比较频繁的 小的对象都分配到它这里，新生代采用**Scavenge算法**来处理。**就是把新生区分为两个区域，一半是对象区域一半是空闲区域新加入的对象都会存放到对象区域，当对象区域快被填满时，就会进行一次垃圾清理操作**
副垃圾回收器的处理过程：
 - 先对对象区域中的垃圾做标记；
 - 标记完之后就进入清理阶段，把这些存活下来的对象复制到空闲区域
 - 这个复制的过程就是完成了内存整理操作并且没有内存碎片
 - 完成复制后，两个区域进行一个角色翻转，空闲变对象，对象变空闲。这就完成了一次垃圾清除，这种角色翻转的操作还能让新生代中的两块区域无限重复使用下去
 - 但是每次复制操作需要时间所以为了执行的效率，新生区的空间会被设置得比较小
 - 也正是因为空间不大，所以js引擎采取对象晋升的策略，一般经过两轮角色翻转还存活的对象，会被移动到老生区

**2.主垃圾回收器**
 负责老生区的垃圾回收。除了新生区中晋升的对象，一些大的对象都是被分配到老生区。因此老生区对象特点是：对象占用空间大，另一个是对象存活时间长。也正是如此所以使用副垃圾处理器的Scavenge算法复制对象效率不高。因而采用标记清除算法
  - 首先标记阶段，从一组根元素开始递归遍历只要是能到达的对象称为活动对象，没有达到的就可以判断为垃圾数据
  - 还是上面的为例，showName函数执行上下文弹出后ESP向下指向foo，如果遍历调用栈是不会发现d中的地址引用，也就意味着d中在堆空间存储的内存是垃圾数据，由于b变量还在引用所以会被标记为活动对象，这就是大致的标记过程（其实这个根我就可以当作是window我们的变量和函数都是window的属性和方法）
  - 但是还有一个关键点需要注意：不断连续的标记清除可能会产生我们之前说的内存碎片，而碎片过多又会导致对象无法分配到足够的连续内存
  - 于是又有了标记整理算法，这个过程区别只在于一个清除改为了整理，让所有存活的对象都向一端移动，然后直接清理边界意外的碎片
**全停顿** 我们知道js是单线程的，一旦执行垃圾回收机制算法，都需将正在执行的脚本暂停掉，等回收完再执行，这种行为就是全停顿。再V8的新生代垃圾回收中，因空间较小且存货对象较小所以全停顿的影响就不大，但是老生代不同，如果时间过长，比如页面正在执行一个200ms的js动画，因为垃圾回收再工作就会导致这动画再200ms内无法执行，页面就会有卡顿。
为了降低老生代的全停顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和js逻辑交替穿插进行，直到标记阶段完成，这个算法称为增量标记算法。

#### IE还在用的回收算法
引用计数算法：引用大可理解为就是指向堆中数据的指针，本质就是看一个对象是否有指向它的引用，如果没有就证明没有其他在用，表示对象不在需要了
```javascript
var person = {
  age: 12,
  sex: "male",
  name: :"mike"
};
paerson.name = null;
var p = person;
person = 1;
p = null;
流程就是，我创建了一个person对象，即使给name属性释放掉，但不会释放整体的引用，将person的引用又赋值给了变量p所以，现在有两个变量保存着指针，person被赋值给了存储的指针就被替换成了数值类型，然后p又被赋值成了null就相当于没有引用了，很快就被回收掉。
```
上面这个例子可以看出来，直观上来看确实是简单有效，但是存在的问题也很致命
```javascript
function fn() {
  var o1 = {};
  var o2 = {};
  o1.a = o2;
  o2.a = o1;
  return "Ignorant--懵逼"
}
fn();

这个fn函数在执行上下文弹栈后，o1和o2已经不需要了但是根据引用计数的原则他们之间依然存在着引用，无法回收意味着内存泄漏不可避免了，也就是这个问题，已经被现代浏览器的标记清除算法给替代了，但是臭名昭著的IE还在使用
```

## 内存泄露
一个页面是一个持续运行的进程，如果不能及时的释放不在用到的内存。内存占用越来越高，就会影响系统性能，导致进程崩溃。不在用到的内存，没有及时释放就叫做内存泄漏。（只要程序提出要求，操作系统就必须提供）
**识别泄露方法**（具体操作会按体系去写）
 1.浏览器方法：开发者工具选择Memory点击左上角录制。。。
 2.命令行：Node提供了process.memoryUsage接口
 3.ES6新概念针对及时清除引用推出了两个新的数据结构weakSet和weakMap
 **常见内存泄露**
  - 意外的全局变量
```javascript
function fn() {
  b = 10;
}
fn();
//实际上就是
function fn() {
  window.b = 10;
}
fn();
//如果忘记了使用var关键字声明它，就相当于创建一个全局变量，虽然一个简单的数值不会造成太大的问题，但它就是一个错误

function func() {
  this.d = "foreDawn";
}
func();
//这个this的指向肯定是指向window，所以相当于给window身上添加一个d属性 为了防止你可以在顶部添加严格模式，避免创建意外的全局变量

//关于var的全局变量，由于全局变量是全局执行上下文销毁才会释放其中的内存，需要等到页面关闭才会销毁，所以全局变量很大程度是不会被回收的，所以务必手动释放它
```
 - 使用定，延时器或回调函数
```javascript
var someAsync = getData();
setInterval(() => {
  var ele = document.querSelector("div");
  ele.innerHTML = JSON.stringify(getData());
},1000)

//这里计时器是需要一个开关的，他只有在停止的时候才会被回收，那么内部的getData()可能返回大量的数据 所以clearTimer手动释放它
```
 - 注册事件与循环引用
```javascript
var ele = document.querSelector("div");
ele.addEventListener("click",function() {
  ele.innerHTML = "test";
)

// 首先对于这种循环引用问题，IE肯定是无法解决的了。。。还是需要手动释放的
```
 - 脱离DOM引用
这点就是直接删除DOM树上的引用还有内存中的引用
 - 闭包
需要手动释放