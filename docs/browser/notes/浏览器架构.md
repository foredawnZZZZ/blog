## 浏览器是多进程的
#### 什么是并行处理？

```html
a = 10 + 10;
b = 20 + 1;
c = 20 / 10;
d = 20 * 1
如果是单线程的话 就需要五个步骤 任务1，2，3，4分别执行 任务5就是显示计算的结果
如果是多线程的话 只需要两步 四个线程同时执行任务1，2，3，4 最后显示
<b>并行处理其实就是同一时刻处理多个任务提升了性能</b>
```



#### 线程与进程

```html
多线程虽然可以进行并行任务，但是线程是不能单独存在的 他是有进程启动和管理的
启动程序时 操作系统会为该程序创建一个内存 用来存代码和数据还有一个执行任务的主线程这样的一个运行环境就叫进程
所以： 线程依附于进程，而进程中使用多线程并行处理提升运算效率

（工厂资源：系统分配的内存他是独立的； 工厂之间相互独立：进程之间独立； 多个工人协作： 多线程进行任务； 一个或多个
工人： 一个进程由一个或多个线程组成； 工人之间共享空间： 同一进程下的各线程共享内存中的代码数据）
当一个进程关闭的时候，操作系统也就回收了他的内存
各个进程之间都是独立的内容时相互隔离 避免一个进程挂掉所以的进程跟着受影响 但是不代表完全不可以跨进程通信（IPC机制？？？？）
```



- **单进程浏览器**
  - 单进程的浏览器时指网络，插件，js环境，渲染引擎，页面都在一个进程里早在2007年之前基本都是
  - 任意一个环节出了问题整个浏览器就崩掉了（无限循环的脚本，插件的崩溃，页面的内存泄露）

- **多进程浏览器**
  - 2008年谷歌推出了自家浏览器 各个进程之间相互独立，通过IPC机制进行通信
  - 由于进程相互隔离，页面和插件崩溃只影响到当前，js引擎阻塞渲染，也只是当前渲染页面
  - 安全上用的是沙箱

```html
仅仅打开了 1 个页面，为什么有 4 个进程？
因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。
每开一个tab页就相当开了一个进程 当然这不是绝对的 浏览器会监听当打开多个空白的tab会自动合并在一起

- 浏览器的主进程主要负责用户交互，子进程管理，和文件存储等功能
- 网络进程是面向渲染进程和主进程等提供网络下载
- 渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。
```



### FP（First Paint）

**指从页面加载到首次开始绘制的时长**。这个指标直接影响了用户的跳出率

如何保证页面文件能被完整的传达到浏览器？



## 导航流程

- 用户从浏览器输入请求信息
- 网络进程发起URL请求
- 服务器响应后，浏览器开始准备渲染进程
- 准备之后开始提交文档阶段
- 开始解析页面加载子资源

**用户发出 URL 请求到页面开始解析的这个过程，就叫做导航**。

##### <u>在浏览器里，从输入 URL 到页面展示，这中间发生了什么？</u>

- **用户输入**
  - 在地址栏输入关键字时，会判断时搜索内容还是，请求URL
  - 如果是内容地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。
  - 如果是符合URL规则，那么就会附加上协议合成完整的URL
  - 我们在地址栏输入后 回车时地址前面那个转圈圈其实就是等待提交文档阶段！

- **URL请求过程**
  - 主进程会利用IPC机制把URL请求发送给网络进程 网络进程接收到URL后才会发真正的请求
  - 先会去查找本地缓存是否有，有就直接返回资源给主进程 没有进入流程
  - 先去DNS域名解析 获取对应的IP地址（https先要建立TLS链接）
  - 利用IP地址通过三次握手建立TCP链接 浏览器构建请求行头体
  - 服务器接收后生成相应行头体 给到网络进程 开始解析（对解析后的结果）
    - 重定向：在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。（一般跳转的地址在头的location字段）；
    - 响应数据类型：根据Content-Type字段区分数据类型，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。如果 Content-Type 字段的值被浏览器判断为**下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束**。但如果是**HTML，那么浏览器则会继续进行导航流程**。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

- **准备渲染阶段**
  - 每开开启一个tab就会开启一个渲染进程
  - **如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程反之不会**
  - 只有同一站点的情况下多个页面才会同时运行在一个渲染进程中（根域名加上协议包含该根下的所以子域以及不同端口）

- **提交文档**
  - 文档指的是请求的数据
  - 主进程发起 渲染进程接收和网络进程建立传输
  - 传输完渲染进程会返回“**确认提交**”的消息给浏览器进程。
  - 浏览器进程在收到“确认提交”的消息后，会**更新浏览器界面状态**，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。所以说之前页面没有马上消失而是要加载一会

- **渲染阶段！**

  - 经过HTML解析器，构建DOM树（因为浏览器无法直接识别html，所以需要将转为理解的结构）
  - 也会进行一个转换操作并且**标准化**（2rem = 32px blue = rgb（0，0，255）） ，**计算树节点具体样式**（根据继承和层叠原则） 生成样式结构表
  - 创建布局树（遍历可见树节点  像head和displaynone属于不可以见）
  - 分层图层树 
    - **渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树！**（3D变换，Z轴排序等）
    - **浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面**。
    - **并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层**。但不管怎么样每个节点最终都会属于一个图层
    - 一般满足层叠上下文属性和剪裁（Z-index overflow）

  - .................先略